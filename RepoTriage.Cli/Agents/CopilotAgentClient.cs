using System.Net.Http.Headers;
using System.Runtime.CompilerServices;
using System.Text;
using System.Text.Json;
using Microsoft.Agents.AI;
using RepoTriage.Cli.Models;

namespace RepoTriage.Cli.Agents;

/// <summary>
/// Microsoft Agent Framework implementation of <see cref="ICopilotAgentClient"/>
/// using the GitHub Copilot Agent pattern with tool/function calling.
/// </summary>
public sealed class CopilotAgentClient : ICopilotAgentClient
{
    private readonly HttpClient _http;
    private readonly bool _mock;
    // GitHubToken reserved for future CopilotClient authentication in Phase 4
    private readonly string? _gitHubToken;

    public CopilotAgentClient(string? gitHubToken = null, bool mock = false)
    {
        _mock = mock;
        _gitHubToken = gitHubToken;
        _http = new HttpClient();
        _http.DefaultRequestHeaders.UserAgent.Add(new ProductInfoHeaderValue("RepoTriageCli", "1.0"));

        if (!string.IsNullOrEmpty(gitHubToken))
        {
            _http.DefaultRequestHeaders.Authorization =
                new AuthenticationHeaderValue("Bearer", gitHubToken);
        }
    }

    /// <inheritdoc />
    public Task InitializeAsync(CancellationToken ct = default)
    {
        // For now, initialization is not needed in mock mode or with REST API
        // Future: Initialize CopilotClient when the SDK is fully available
        return Task.CompletedTask;
    }

    /// <inheritdoc />
    public async Task<PullRequestInput> GetPullRequestAsync(Uri prUrl, CancellationToken ct)
    {
        if (_mock)
        {
            return new PullRequestInput(
                Title: "feat: add user authentication module",
                Body: "This PR adds JWT-based authentication with login and signup endpoints.",
                Diff: MockData.SampleDiff,
                FilesChanged: ["src/auth/login.cs", "src/auth/signup.cs", "tests/auth/loginTests.cs"]);
        }

        // Parse owner/repo/number from PR URL (e.g. https://github.com/OWNER/REPO/pull/123)
        var segments = prUrl.AbsolutePath.Trim('/').Split('/');
        if (segments.Length < 4 || segments[2] != "pull")
        {
            throw new ArgumentException($"Invalid PR URL format: {prUrl}");
        }

        var owner = segments[0];
        var repo = segments[1];
        var number = segments[3];

        var apiUrl = $"https://api.github.com/repos/{owner}/{repo}/pulls/{number}";

        var json = await _http.GetStringAsync(apiUrl, ct);
        using var doc = JsonDocument.Parse(json);
        var root = doc.RootElement;

        var title = root.GetProperty("title").GetString() ?? "";
        var body = root.GetProperty("body").GetString() ?? "";

        // Fetch the diff
        var diffUrl = $"{apiUrl}.diff";
        using var diffRequest = new HttpRequestMessage(HttpMethod.Get, diffUrl);
        diffRequest.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue("application/vnd.github.v3.diff"));
        var diffResponse = await _http.SendAsync(diffRequest, ct);
        var diff = await diffResponse.Content.ReadAsStringAsync(ct);

        // Fetch changed files
        var filesUrl = $"{apiUrl}/files";
        var filesJson = await _http.GetStringAsync(filesUrl, ct);
        using var filesDoc = JsonDocument.Parse(filesJson);
        var files = filesDoc.RootElement.EnumerateArray()
            .Select(f => f.GetProperty("filename").GetString() ?? "")
            .ToList();

        return new PullRequestInput(title, body, diff, files);
    }

    /// <inheritdoc />
    public Task<string> GetDiffAsync(PullRequestInput pr, CancellationToken ct)
    {
        return Task.FromResult(pr.Diff);
    }

    /// <inheritdoc />
    public Task<string> DraftCommentAsync(
        string summary, IReadOnlyList<string> risks, IReadOnlyList<string> checklist,
        string prTitle, CancellationToken ct)
    {
        var risksSection = risks.Count > 0
            ? string.Join("\n", risks.Select(r => $"- âš ï¸ {r}"))
            : "- No significant risks identified.";

        var checklistSection = string.Join("\n", checklist.Select(c => $"- [ ] {c}"));

        var comment = $"""
            ## ðŸ¤– Repo Triage â€” {prTitle}

            ### Summary
            {summary}

            ### âš ï¸ Risks / Questions
            {risksSection}

            ### âœ… Review Checklist
            {checklistSection}

            ---
            > _Generated by Repo Triage Agent_
            """;

        return Task.FromResult(comment);
    }

    /// <inheritdoc />
    public async IAsyncEnumerable<string> DraftCommentStreamingAsync(
        string summary, IReadOnlyList<string> risks, IReadOnlyList<string> checklist,
        string prTitle, [EnumeratorCancellation] CancellationToken ct)
    {
        // For now, return the full comment at once
        // Future: Implement streaming via ChatClientAgent or CopilotClient when available
        var fullComment = await DraftCommentAsync(summary, risks, checklist, prTitle, ct);
        yield return fullComment;
    }

    public ValueTask DisposeAsync()
    {
        _http.Dispose();
        return ValueTask.CompletedTask;
    }
}

internal static class MockData
{
    public const string SampleDiff = """
        diff --git a/src/auth/login.cs b/src/auth/login.cs
        new file mode 100644
        --- /dev/null
        +++ b/src/auth/login.cs
        @@ -0,0 +1,25 @@
        +public class LoginHandler
        +{
        +    public async Task<AuthResult> HandleAsync(LoginRequest request)
        +    {
        +        var user = await _userRepo.FindByEmailAsync(request.Email);
        +        if (user == null) return AuthResult.Fail("User not found");
        +        var valid = _hasher.Verify(request.Password, user.PasswordHash);
        +        if (!valid) return AuthResult.Fail("Invalid password");
        +        return AuthResult.Ok(_tokenService.Generate(user));
        +    }
        +}
        """;
}
